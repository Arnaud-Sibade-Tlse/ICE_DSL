/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import sAAP.StateMachine
import sAAP.State
import sAAP.Transition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FsmGenerator extends AbstractGenerator {
	 
	 val String DEFAULT_PACKAGE = "saap.Xtend.main";
	 val String DEFAULT_PATH = "";
	 var StateMachine stateMachine;
	 
	 
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		this.stateMachine = resource.contents.get(0) as StateMachine;
		fsa.generateFile(DEFAULT_PATH + '/State.java', printAbstractState())
		stateMachine.state.forEach [ st |
			fsa.generateFile(DEFAULT_PATH + '/' + st.name.toFirstUpper() + '.java', st.print)
		]
		stateMachine.transition.forEach [ tr |
			fsa.generateFile(DEFAULT_PATH + '/' + tr.name.toFirstUpper() + '.java', tr.print)
		]
		fsa.generateFile(stateMachine.name.toFirstUpper() + '.java', stateMachine.print)
	}
	
	def print(StateMachine stateMachine) {
		var stateMachineUpper = stateMachine.name.toFirstUpper();
		var stateMachineLower = stateMachine.name.toFirstLower();
		
		'''
			package «DEFAULT_PACKAGE»;
				
			import java.util.Scanner;
			import java.util.ArrayList;
			import java.util.List;
			
			public class «stateMachineUpper» {
			
				private State current;
				
				private List<State> states = new ArrayList();
				
				«stateMachine.initializeFSM()»
				
				public «stateMachineUpper»() {
					«FOR state : stateMachine.state»
						«IF state.^default»
							this.current = new «state.name.toFirstUpper»();
						«ENDIF»
					«ENDFOR»
					
					// Adding every states
					«FOR state : stateMachine.state»
						this.states.add(new «state.name.toFirstUpper()»());
					«ENDFOR»
				}
				
				/**
				 * Hande the state change.
				 * @param transition, the transition name wanted by the user.
				 */
				 public String next(String transition){
				 «FOR transition : stateMachine.transition»
				 	// «transition.name» transition from «transition.from.name» to «transition.to.name»
				 	if(transition.toLowerCase().equals("«transition.name»".toLowerCase())) {
				 		
				 		// If the current state is «transition.from.name»
				 		if("«transition.from.name»".equals(this.current.getName())) {
				 		
				 			this.current = states.stream().filter(state -> state.getName().equals("«transition.to.name»")).findFirst().get();
				 			return "Transition : «transition.name» from «transition.from.name» to «transition.to.name»";
				 		} else {
				 			return "## Can't run transition «transition.name» because the current state is "+this.current.getName()+" and should be «transition.from.name»";
				 		}
				 	}
				 	
				«ENDFOR»
				else
				{
					return "transition " + transition + " does not exists.";
				}
				}
				
				public static void main(String[] args) {
					// Create a new StateMachine
					«stateMachineUpper» «stateMachineLower» = new «stateMachine»();
					
					// First print the init state
					System.out.println("Starting the «stateMachine» ... press 'exit' to stop.");
					System.out.println("## The init state is : " + «stateMachineUpper».current.getName());
				
						Scanner scanner = new Scanner(System.in);
						String entry = "";
						// Main loop
						while (!entry.equals("exit")) {
							System.out.println("## Choose a transition/exit :");
							entry = scanner.nextLine();
							
							// Change the desired state
							String result = «stateMachineLower».next(entry);
							
							if (result != null){
								System.out.println(result);
							}
							
							System.out.println("## The current state is : " + «stateMachineLower».current.getName());
							
						}
						
						System.out.println("«stateMachineUpper» has been stopped.");
						
				}
				
				«printGetterAndSetter("State", "current")»
				}
		'''
	}
	
	def printGetterAndSetter(String string, String string2) {
		val attributeNameUpper = string2.toFirstUpper()
		val attributeNameLower = string2.toFirstLower()
		val typeUpper = string.toFirstUpper()

		// Print the getter and setter content
		'''
			/**
			 * Getter of «attributeNameLower».
			 */
			public «typeUpper» get«attributeNameUpper»(){
				return this.«attributeNameLower»;
			}
			
			/**
			 * Setter of «attributeNameLower».
			 */
			public void set«attributeNameUpper»(«typeUpper» «attributeNameLower»){
				this.«attributeNameLower» = «attributeNameLower»;
			}
		'''
	}
	
	def void initializeFSM(StateMachine machine){
		println("hello")
		//TODO : VM ?
	}
	
	def print(State state) {
		var stateName = state.name.toFirstUpper()
		
		'''
			package «DEFAULT_PACKAGE»;
			
			/**
			 * Represent a specific {@link State}.
			 * @author generated
			 */
			public class «stateName» extends State {
				
				public «stateName»(){
					this.setName("«stateName.toFirstLower()»");
				}		
			}
		'''
	}
	
	def print(Transition transition) {
		var transitionName = transition.name.toFirstUpper()
		
		'''
			package «DEFAULT_PACKAGE»;
			
			/**
			 * Represent a specific {@link State}.
			 * @author generated
			 */
			public class «transitionName» extends State {
				
				public «transitionName»(){
					this.setName("«transitionName.toFirstLower()»");
				}		
			}
		'''
	}
	
	def printAbstractState() { '''
		package «DEFAULT_PACKAGE»;
		
		/**
		 * A State used by a {@Link «stateMachine.name.toFirstUpper()»}
		 * @author generated
		 */
		public abstract class State {
			
			private String name;
					
			«printGetterAndSetter(State.name.class.simpleName, 'name')»
		}
	'''
	}
	
}
